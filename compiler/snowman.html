<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon.ico">
    <link href="/styles.css" rel="stylesheet">
    <title>Snowball Manual</title>
  </head>

  <body bgcolor="white">
<TABLE WIDTH=75% ALIGN=CENTER COLS=1>
<H1 ALIGN=CENTER>Snowball Manual</H1>
<TR><TD BGCOLOR="wheat">
<BR>&nbsp;<H2>Links to resources</H2>
<DL><DD><TABLE CELLPADDING=0>
<TR><TD><A HREF=".."> Snowball main page</A>
<TR><TD><A HREF="../runtime/use.html">          Using Snowball</A>
<TR><TD><A HREF="../algorithms/porter/stemmer.html"> Porter stemmer &#x2014; a case study</A>
</TABLE></DL>
</TR>

<TR><TD>
<BR><BR>

<BR>&nbsp;<H2>Snowball definition</H2>

Snowball is a small string-handling language, and its name was chosen as a
tribute to SNOBOL (Farber 1964, Griswold 1968 &#x2014;
see the references at the end of the
<A HREF="../texts/introduction.html">introduction</A>),
with which it shares the
concept of string patterns delivering signals that are used to control the
flow of the program.

<BR>&nbsp;<H2>1 Data types</H2>

The basic data types handled by Snowball are strings of characters, signed
integers, and boolean truth values, or more simply <I>strings</I>, <I>integers</I>
and <I>booleans</I>. Snowball's characters are either 8-bit wide, or
16-bit, depending on the mode of use. In particular, both 8-bit
ASCII and 16-bit Unicode are supported.

<BR>&nbsp;<H2>2 Names</H2>

A name in Snowball is a letter followed by zero or more letters, digits
and underlines. A name can be of type <I>string</I>, <I>integer</I>, <I>boolean</I>,
<I>routine</I>, <I>external</I> or <I>grouping</I>. All names must be declared. A
declaration has the form
<BR><PRE>
    Ts ( ... )
</PRE>
where symbol &nbsp;<code>T</code>&nbsp; is one of &nbsp;<code>string</code>, &nbsp;<code>integer</code>&nbsp; etc, and the region in
brackets contains a list of names separated by whitespace. For example,
<BR>
<div class="highlight"><pre>    <span class="kd">integers</span> <span class="p">(</span> <span class="n">p1</span> <span class="n">p2</span> <span class="p">)</span>
    <span class="kd">booleans</span> <span class="p">(</span> <span class="n">Y_found</span> <span class="p">)</span>

    <span class="kd">routines</span> <span class="p">(</span>
       <span class="n">shortv</span>
       <span class="n">R1</span> <span class="n">R2</span>
       <span class="n">Step_1a</span> <span class="n">Step_1b</span> <span class="n">Step_1c</span> <span class="n">Step_2</span> <span class="n">Step_3</span> <span class="n">Step_4</span> <span class="n">Step_5a</span> <span class="n">Step_5b</span>
    <span class="p">)</span>

    <span class="kd">externals</span> <span class="p">(</span> <span class="n">stem</span> <span class="p">)</span>

    <span class="kd">groupings</span> <span class="p">(</span> <span class="n">v</span> <span class="n">v_WXY</span> <span class="n">v_LSZ</span> <span class="p">)</span>
</pre></div>

<code>p1</code>&nbsp; and &nbsp;<code>p2</code>&nbsp; are integers, &nbsp;<code>Y_found</code>&nbsp; is boolean, and so on. Snowball is quite
strict about the declarations, so all the names go in the same name space,
no name may be declared twice, all used names must be declared, no two
routine definitions can have the same name, etc. Names declared and
subsequently not used are merely reported in a warning message. A name may
not be one of the reserved words of Snowball.

<BR>&nbsp;<H2>3 Literals</H2>

A literal integer is a digit sequence, and is always interpreted as
decimal. A literal string is written between single quotes, for example,

<div class="highlight"><pre>    <span class="s">&#39;aeiouy&#39;</span>
</pre></div>


In a &nbsp;<code>stringdef</code>&nbsp; (see below), string may be preceded by the word &nbsp;<code>hex</code>,
or the word &nbsp;<code>decimal</code>,
in which case the contents are
interpreted as characters written out in hexadecimal, or decimal, notation.
The characters should be separated by spaces. For example,

<div class="highlight"><pre>    <span class="mh">hex</span> <span class="s">&#39;DA&#39;</span>        <span class="cm">/* is character hex DA */</span>
    <span class="mh">hex</span> <span class="s">&#39;D A&#39;</span>       <span class="cm">/* is the two characters, hex D and A (carriage</span>
<span class="cm">                       return, and line feed) */</span>
    <span class="mi">decimal</span> <span class="s">&#39;10&#39;</span>    <span class="cm">/* character 10 (line feed) */</span>
    <span class="mi">decimal</span> <span class="s">&#39;13 10&#39;</span> <span class="cm">/* characters 13 and 10 (carriage return, and</span>
<span class="cm">                       line feed) */</span>
</pre></div>


The following forms are equivalent,

<div class="highlight"><pre>    <span class="mh">hex</span> <span class="s">&#39;d a&#39;</span>      <span class="cm">/* lower case also allowed */</span>
    <span class="mh">hex</span> <span class="s">&#39;0D 000A&#39;</span>  <span class="cm">/* leading zeroes ignored */</span>
    <span class="mh">hex</span> <span class="s">&#39; D  A  &#39;</span>  <span class="cm">/* extra spacing is harmless */</span>
</pre></div>


<code>stringdef</code>s define special <I>string macros</I>, to handle unusual
character combinations.
<BR><BR>
Macro &nbsp;<code>m</code>&nbsp; is defined in the form &nbsp;<code>stringdef m 'S'</code>, where &nbsp;<code>'S'</code>&nbsp; is a
string, and &nbsp;<code>m</code>&nbsp; a sequence of one or more printing characters terminating
with whitespace.
<BR><BR>
Two special <I>insert characters</I> are defined by the directive
<span class="highlight"><code><span class="n">stringescapes</span> <span class="n">AB</span>
</code></span>

, where &nbsp;<code>A</code>&nbsp; and &nbsp;<code>B</code>&nbsp; are printing characters, and &nbsp;<code>A</code>&nbsp; is not
single quote. (<code>B</code>&nbsp; may equal &nbsp;<code>A</code>, but then &nbsp;<code>A</code>&nbsp; itself can never be escaped.) For
example,

<div class="highlight"><pre>    <span class="kd">stringescapes</span> <span class="p">{}</span>
</pre></div>


A subsequent occurrence of the same directive redefines the insert
characters.
<BR><BR>
Thereafter, &nbsp;<code>{m}</code>&nbsp; inside a string causes &nbsp;<code>S</code>&nbsp; to be substituted in place of &nbsp;<code>m</code>.
<BR><BR>
Immediately after the stringescapes directive, &nbsp;<code>{'}</code>&nbsp; will substitute &nbsp;<code>'</code>&nbsp; and
<code>{{}</code>&nbsp; will substitute &nbsp;<code>{</code>, although macros &nbsp;<code>'</code>&nbsp; and &nbsp;<code>{</code>&nbsp; may subsequently be
redefined. A further feature is that &nbsp;<code>{<I>W</I>}</code>&nbsp; inside a string, where &nbsp;<code><I>W</I></code>&nbsp; is a
sequence of whitespace characters including one or more newlines, is
ignored. This enables long strings to be written over a number of lines.
<BR><BR>
For example,

<div class="highlight"><pre>    <span class="kd">stringescapes</span> <span class="p">{}</span>

    <span class="cm">/* special Spanish characters */</span>

    <span class="kd">stringdef</span> <span class="n">a&#39;</span>   <span class="mh">hex</span> <span class="s">&#39;00E1&#39;</span>  <span class="c1">// a-acute</span>
    <span class="kd">stringdef</span> <span class="n">e&#39;</span>   <span class="mh">hex</span> <span class="s">&#39;00E9&#39;</span>  <span class="c1">// e-acute</span>
    <span class="kd">stringdef</span> <span class="n">i&#39;</span>   <span class="mh">hex</span> <span class="s">&#39;00ED&#39;</span>  <span class="c1">// i-acute</span>
    <span class="kd">stringdef</span> <span class="n">o&#39;</span>   <span class="mh">hex</span> <span class="s">&#39;00F3&#39;</span>  <span class="c1">// o-acute</span>
    <span class="kd">stringdef</span> <span class="n">u&#39;</span>   <span class="mh">hex</span> <span class="s">&#39;00FA&#39;</span>  <span class="c1">// u-acute</span>
    <span class="kd">stringdef</span> <span class="n">u&quot;</span>   <span class="mh">hex</span> <span class="s">&#39;00FC&#39;</span>  <span class="c1">// u-diaeresis</span>
    <span class="kd">stringdef</span> <span class="n">n~</span>   <span class="mh">hex</span> <span class="s">&#39;00F1&#39;</span>  <span class="c1">// n-tilde</span>

    <span class="cm">/* and in the next string we define all the characters in Spanish</span>
<span class="cm">       used to represent vowels</span>
<span class="cm">    */</span>

    <span class="kd">define</span> <span class="n">v</span> <span class="s">&#39;aeiou{a&#39;}{e&#39;}{i&#39;}{o&#39;}{u&#39;}{u&quot;}&#39;</span>
</pre></div>


<p>Conventionally <code>{</code> and <code>}</code> are used as the insert
characters.  We'd recommend following this convention unless you want to use
these as literal characters in your strings.</p>

<BR>&nbsp;<H2>4 Routines</H2>

A routine definition has the form

<div class="highlight"><pre>    <span class="kd">define</span> <span class="n">R</span> <span class="k">as</span> <span class="n">C</span>
</pre></div>


where &nbsp;<code>R</code>&nbsp; is the routine name and &nbsp;<code>C</code>&nbsp; is a command, or bracketed group of
commands. So a routine is defined as a sequence of zero or more commands.
Snowball routines do not (at present) take parameters. For example,

<div class="highlight"><pre>    <span class="kd">define</span> <span class="n">Step_5b</span> <span class="k">as</span> <span class="p">(</span>      <span class="c1">// this defines Step_5b</span>
        <span class="p">[</span><span class="s">&#39;l&#39;</span><span class="p">]</span>                <span class="c1">// three commands here: [, &#39;l&#39; and ]</span>
        <span class="n">R2</span> <span class="s">&#39;l&#39;</span>               <span class="c1">// two commands, R2 and &#39;l&#39;</span>
        <span class="ow">delete</span>               <span class="c1">// delete is one command</span>
    <span class="p">)</span>

    <span class="kd">define</span> <span class="n">R1</span> <span class="k">as</span> <span class="o">$</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="ow">cursor</span>
        <span class="cm">/* R1 is defined as the single command &quot;$p1 &lt;= cursor&quot; */</span>
</pre></div>


A routine is called simply by using its name, &nbsp;<code>R</code>, as a command.

<BR>&nbsp;<H2>5 Commands and signals</H2>

The flow of control in Snowball is arranged by the implicit use of
<I>signals</I>, rather than the explicit use of constructs like the &nbsp;<code>if</code>,
<code>then</code>, &nbsp;<code>break</code>&nbsp; of C. The scheme is designed for handling strings, but is
perhaps easier to introduce using integers. Suppose &nbsp;<code>x</code>, &nbsp;<code>y</code>, &nbsp;<code>z</code>&nbsp; ... are
integers. The command

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="o">=</span> <span class="m">1</span>
</pre></div>


sets &nbsp;<code>x</code>&nbsp; to 1. The command

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span>
</pre></div>


tests if &nbsp;<code>x</code>&nbsp; is greater than zero. Both commands give a signal <B><I>t</I></B> or <B><I>f</I></B>,
(<I>true</I> or <I>false</I>), but while the second command gives <B><I>t</I></B> if &nbsp;<code>x</code>&nbsp; is greater
than zero and <B><I>f</I></B> otherwise, the first command always gives <B><I>t</I></B>. In Snowball,
every command gives a <B><I>t</I></B> or <B><I>f</I></B> signal. A sequence of commands can be turned
into a single command by putting them in a list surrounded by round
brackets:
<BR><PRE>
    ( C<SUB>1</SUB> C<SUB>2</SUB> C<SUB>3</SUB> ... C<SUB>i</SUB> C<SUB>i+1</SUB> ... )
</PRE>
When this is obeyed, &nbsp;<code>C<SUB>i+1</SUB></code>&nbsp; will be obeyed if each of the preceding &nbsp;<code>C<SUB>1</SUB></code>&nbsp; ...
<code>C<SUB>i</SUB></code>&nbsp; give <B><I>t</I></B>, but as soon as a &nbsp;<code>C<SUB>i</SUB></code>&nbsp; gives <B><I>f</I></B>, the subsequent &nbsp;<code>C<SUB>i+1</SUB> C<SUB>i+2</SUB></code>&nbsp; ...
are ignored, and the whole sequence gives signal <B><I>f</I></B>. If all the &nbsp;<code>C<SUB>i</SUB></code>&nbsp; give <B><I>t</I></B>,
however, the bracketed command sequence also gives <B><I>t</I></B>. So,

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="o">$</span><span class="n">y</span> <span class="o">=</span> <span class="m">1</span>
</pre></div>


sets &nbsp;<code>y</code>&nbsp; to 1 if &nbsp;<code>x</code>&nbsp; is greater than zero. If &nbsp;<code>x</code>&nbsp; is less than or equal to zero
the two commands give <B><I>f</I></B>.
<BR><BR>
If &nbsp;<code>C<SUB>1</SUB></code>&nbsp; and &nbsp;<code>C<SUB>2</SUB></code>&nbsp; are commands, we can build up the larger commands,
<DL><DD><DL>
    <DT><code>C<SUB>1</SUB> or C<SUB>2</SUB></code>
        <DD>&#x2014; Do &nbsp;<code>C<SUB>1</SUB></code>. If it gives <B><I>t</I></B> ignore &nbsp;<code>C<SUB>2</SUB></code>, otherwise do &nbsp;<code>C<SUB>2</SUB></code>. The resulting
        signal is <B><I>t</I></B> if and only &nbsp;<code>C<SUB>1</SUB></code>&nbsp; or &nbsp;<code>C<SUB>2</SUB></code>&nbsp; gave <B><I>t</I></B>.
    <DT><code>C<SUB>1</SUB> and C<SUB>2</SUB></code>
        <DD>&#x2014; Do &nbsp;<code>C<SUB>1</SUB></code>. If it gives <B><I>f</I></B> ignore &nbsp;<code>C<SUB>2</SUB></code>, otherwise do &nbsp;<code>C<SUB>2</SUB></code>. The resulting
        signal is <B><I>t</I></B> if and only &nbsp;<code>C<SUB>1</SUB></code>&nbsp; and &nbsp;<code>C<SUB>2</SUB></code>&nbsp; gave <B><I>t</I></B>.
    <DT><code>not C</code>
        <DD>&#x2014; Do &nbsp;<code>C</code>. The resulting signal is <B><I>t</I></B> if &nbsp;<code>C</code>&nbsp; gave <B><I>f</I></B>, otherwise <B><I>f</I></B>.
    <DT><code>try C</code>
        <DD>&#x2014; Do &nbsp;<code>C</code>. The resulting signal is <B><I>t</I></B> whatever the signal of &nbsp;<code>C</code>.
    <DT><code>fail C</code>
        <DD>&#x2014; Do &nbsp;<code>C</code>. The resulting signal is <B><I>f</I></B> whatever the signal of &nbsp;<code>C</code>.
</DL></DL>
So for example,
<DL><DD><DL>
    <DT><span class="highlight"><code><span class="p">(</span><span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="o">$</span><span class="n">y</span> <span class="o">=</span> <span class="m">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="o">$</span><span class="n">y</span> <span class="o">=</span> <span class="m">0</span><span class="p">)</span>
</code></span>

        <DD>&#x2014; sets &nbsp;<code>y</code>&nbsp; to 1 if &nbsp;<code>x</code>&nbsp; is greater than zero, otherwise to zero.

    <DT><span class="highlight"><code><span class="ow">try</span><span class="p">(</span> <span class="p">(</span><span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="o">$</span><span class="n">z</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="o">$</span><span class="n">y</span> <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</code></span>

        <DD>&#x2014; sets &nbsp;<code>y</code>&nbsp; to 1 if both &nbsp;<code>x</code>&nbsp; and &nbsp;<code>z</code>&nbsp; are greater than 0, and gives <B><I>t</I></B>.
</DL></DL>
This last example is the same as

<div class="highlight"><pre>    <span class="ow">try</span><span class="p">(</span><span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="o">$</span><span class="n">z</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="o">$</span><span class="n">y</span> <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</pre></div>


so that &nbsp;<code>and</code>&nbsp; seems unnecessary here. But we will see that &nbsp;<code>and</code>&nbsp; has a
particular significance in string commands.
<BR><BR>
When a &#8216;monadic&#8217; construct like &nbsp;<code>not</code>, &nbsp;<code>try</code>&nbsp; or &nbsp;<code>fail</code>&nbsp; is not followed by a
round bracket, the construct applies to the shortest following valid command.
So for example

<div class="highlight"><pre>    <span class="ow">try</span> <span class="ow">not</span> <span class="o">$</span><span class="n">x</span> <span class="o">&lt;</span> <span class="m">1</span> <span class="o">$</span><span class="n">z</span> <span class="o">&gt;</span> <span class="m">0</span>
</pre></div>


would mean

<div class="highlight"><pre>    <span class="ow">try</span> <span class="p">(</span> <span class="ow">not</span> <span class="p">(</span> <span class="o">$</span><span class="n">x</span> <span class="o">&lt;</span> <span class="m">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">$</span><span class="n">z</span> <span class="o">&gt;</span> <span class="m">0</span>
</pre></div>


because <span class="highlight"><code><span class="o">$</span><span class="n">x</span> <span class="o">&lt;</span> <span class="m">1</span>
</code></span>

 is the shortest valid command following &nbsp;<code>not</code>, and then
<code>not $x &lt; 1</code>&nbsp; is the shortest valid command following &nbsp;<code>try</code>.
<BR><BR>
The &#8216;dyadic&#8217; constructs like &nbsp;<code>and</code>&nbsp; and &nbsp;<code>or</code>&nbsp; must sit in a bracketed list
of commands anyway, for example,
<BR><PRE>
    ( C<SUB>1</SUB> C<SUB>2</SUB> and C<SUB>3</SUB> C<SUB>4</SUB> or C<SUB>5</SUB> )
</PRE>
And then in this case &nbsp;<code>C<SUB>2</SUB></code>&nbsp; and &nbsp;<code>C<SUB>3</SUB></code>&nbsp; are connected by the &nbsp;<code>and</code>; &nbsp;<code>C<SUB>4</SUB></code>&nbsp; and &nbsp;<code>C<SUB>5</SUB></code>&nbsp; are
connected by the &nbsp;<code>or</code>. So

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="ow">not</span> <span class="o">$</span><span class="n">y</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="o">$</span><span class="n">z</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="o">$</span><span class="n">t</span> <span class="o">&gt;</span> <span class="m">0</span>
</pre></div>


means

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span>  <span class="p">((</span><span class="ow">not</span> <span class="p">(</span><span class="o">$</span><span class="n">y</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="o">$</span><span class="n">z</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">)))</span>  <span class="o">$</span><span class="n">t</span> <span class="o">&gt;</span> <span class="m">0</span>
</pre></div>


<code>and</code>&nbsp; and &nbsp;<code>or</code>&nbsp; are equally binding, and bind from left to right,
so &nbsp;<code>C<SUB>1</SUB> or C<SUB>2</SUB> and C<SUB>3</SUB></code>&nbsp; means &nbsp;<code>(C<SUB>1</SUB> or C<SUB>2</SUB>) and C<SUB>3</SUB></code>&nbsp; etc.

<BR>&nbsp;<H2>6 AEs and integer commands</H2>

An AE (arithmetic expression) consists of integer names and literal
numbers connected by dyadic &nbsp;<code>+</code>, &nbsp;<code>-</code>, &nbsp;<code>*</code>&nbsp; and &nbsp;<code>/</code>, and monadic &nbsp;<code>-</code>, with the same
binding powers and semantics as C. An integer command has the form
<BR><PRE>
    $X <I>op</I> AE
</PRE>
where &nbsp;<code>X</code>&nbsp; is an integer name and <I>op</I> is one of the six tests &nbsp;<code>==</code>, &nbsp;<code>!=</code>, &nbsp;<code>&gt;=</code>, &nbsp;<code>&gt;</code>,
<code>&lt;=</code>, &nbsp;<code>&lt;</code>, or five assignments &nbsp;<code>=</code>, &nbsp;<code>+=</code>, &nbsp;<code>-=</code>, &nbsp;<code>*=</code>, &nbsp;<code>/=</code>. Again, the meanings are the
same as in C.
<BR><BR>
As well as integer names and literal numbers, the following may be used in
AEs:
<DL><DD><TABLE CELLPADDING=0>
<TR><TD><code>minint</code>&nbsp;   <TD></TD><TD>  &#x2014; the minimum negative number
<TR><TD><code>maxint</code>&nbsp;   <TD></TD><TD>  &#x2014; the maximum positive number
<TR><TD><code>sizeof s</code>&nbsp; <TD></TD><TD>  &#x2014; the number of characters in &nbsp;<code>s</code>, where &nbsp;<code>s</code>&nbsp; is the name of a string
<TR><TD><code>cursor</code>&nbsp;   <TD></TD><TD>  &#x2014; the current value of the string <I>cursor</I>
<TR><TD><code>limit</code>&nbsp;    <TD></TD><TD>  &#x2014; the current value of the string <I>limit</I>
<TR><TD><code>size</code>&nbsp;     <TD></TD><TD>  &#x2014; the size of the string, in characters
</TABLE></DL>
The <I>cursor</I> and <I>limit</I> concepts are explained below.
<BR><BR>
Examples of integer commands are,

<div class="highlight"><pre>    <span class="o">$</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="ow">cursor</span>  <span class="c1">// signal is f if the cursor is before position p1</span>
    <span class="o">$</span><span class="n">p1</span> <span class="o">=</span> <span class="ow">limit</span>    <span class="c1">// set p1 to the string limit</span>
</pre></div>



<BR>&nbsp;<H2>7 String commands</H2>

If &nbsp;<code>s</code>&nbsp; is a string name, a string command has the form
<BR><PRE>
    $s C
</PRE>
where &nbsp;<code>C</code>&nbsp; is a command that operate on the string. Strings can be processed
left-to-right or right-to-left, but we will describe only the
left-to-right case for now. The string has a <I>cursor</I>, which we will
denote by <B><I>c</I></B>, and a limit point, or <I>limit</I>, which we will denote by <B><I>l</I></B>. <B><I>c</I></B>
advances towards <B><I>l</I></B> in the course of a string command, but the various
constructs &nbsp;<code>and</code>, &nbsp;<code>or</code>, &nbsp;<code>not</code>&nbsp; etc have side-effects which keep moving it
backwards. Initially <B><I>c</I></B> is at the start and <B><I>l</I></B> the end of the string. For
example,
<BR><PRE>
        'a|n|i|m|a|d|v|e|r|s|i|o|n'
        |                         |
        c                         l
</PRE>
<B><I>c</I></B>, and <B><I>l</I></B>, mark the boundaries between characters, and not
characters themselves. The characters between <B><I>c</I></B> and <B><I>l</I></B> will be denoted by
<B><I>c:l</I></B>.
<BR><BR>
If &nbsp;<code>C</code>&nbsp; gives <B><I>t</I></B>, the cursor <B><I>c</I></B> will have a new, well-defined value. But if &nbsp;<code>C</code>
gives <B><I>f</I></B>, <B><I>c</I></B> is undefined. Its later value will in fact be determined by the
outer context of commands in which &nbsp;<code>C</code>&nbsp; came to be obeyed, not by &nbsp;<code>C</code>&nbsp; itself.
<BR><BR>
Here is a list of the commands that can be used to operate on strings.

&nbsp;<H4>a) Setting a value</H4>


<DL>
<DT><code>= S</code>
    <DD>where &nbsp;<code>S</code>&nbsp; is the name of a string or a literal string. <B><I>c:l</I></B> is set equal
    to &nbsp;<code>S</code>, and <B><I>l</I></B> is adjusted to point to the end of the copied string. The
    signal is <B><I>t</I></B>. For example,

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span>  <span class="o">=</span> <span class="s">&#39;animadversion&#39;</span>    <span class="cm">/* literal string */</span>
        <span class="o">$</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>                  <span class="cm">/* string name */</span>
</pre></div>


</DL>

&nbsp;<H4>b) Basic tests</H4>

<DL>
<DT><code>S</code>
    <DD>here and below, &nbsp;<code>S</code>&nbsp; is the name of a string or a literal string. If <B><I>c:l</I></B>
    begins with the substring &nbsp;<code>S</code>, <B><I>c</I></B> is repositioned to the end of this
    substring, and the signal is <B><I>t</I></B>. Otherwise the signal is <B><I>f</I></B>. For example,

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="s">&#39;anim&#39;</span>   <span class="cm">/* gives t, assuming the string is &#39;animadversion&#39; */</span>
        <span class="o">$</span><span class="n">x</span> <span class="p">(</span><span class="s">&#39;anim&#39;</span> <span class="s">&#39;ad&#39;</span> <span class="s">&#39;vers&#39;</span><span class="p">)</span>
                    <span class="cm">/* ditto */</span>

        <span class="o">$</span><span class="n">t</span> <span class="o">=</span> <span class="s">&#39;anim&#39;</span>
        <span class="o">$</span><span class="n">x</span> <span class="n">t</span>        <span class="cm">/* ditto */</span>
</pre></div>


<DT><code>true</code>, &nbsp;<code>false</code>
    <DD><code>true</code>&nbsp; is a dummy command that generates signal <B><I>t</I></B>. &nbsp;<code>false</code>&nbsp; generates
    signal <B><I>f</I></B>. They are sometimes useful for emphasis,

<div class="highlight"><pre>        <span class="kd">define</span> <span class="n">start_off</span> <span class="k">as</span> <span class="kc">true</span>       <span class="c1">// nothing to do</span>
        <span class="kd">define</span> <span class="n">exception_list</span> <span class="k">as</span> <span class="kc">false</span> <span class="c1">// put in among(...) list later</span>
</pre></div>


        &nbsp;<code>true</code>&nbsp;      is equivalent to     &nbsp;<code>()</code>
<DT><code>C<SUB>1</SUB> or C<SUB>2</SUB></code>
    <DD>This is like the case for integers described above, but the extra
    touch is that if &nbsp;<code>C<SUB>1</SUB></code>&nbsp; gives <B><I>f</I></B>, <B><I>c</I></B> is set back to its old position after
    &nbsp;<code>C<SUB>1</SUB></code>&nbsp; has given <B><I>f</I></B> and before &nbsp;<code>C<SUB>2</SUB></code>&nbsp; is tried, so that the test takes place on
    the same point in the string. So we have

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="p">(</span><span class="s">&#39;anim&#39;</span>  <span class="cm">/* signal t */</span>
            <span class="s">&#39;ation&#39;</span> <span class="cm">/* signal f */</span>
           <span class="p">)</span> <span class="ow">or</span>
           <span class="p">(</span> <span class="s">&#39;an&#39;</span>   <span class="cm">/* signal t - from the beginning */</span>
           <span class="p">)</span>
</pre></div>


<DT><code>C<SUB>1</SUB> and C<SUB>2</SUB></code>
    <DD>And similarly <B><I>c</I></B> is set back to its old position after &nbsp;<code>C<SUB>1</SUB></code>&nbsp; has given <B><I>t</I></B>
    and before &nbsp;<code>C<SUB>2</SUB></code>&nbsp; is tried. So,

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="s">&#39;anim&#39;</span> <span class="ow">and</span> <span class="s">&#39;an&#39;</span>   <span class="cm">/* signal t */</span>
        <span class="o">$</span><span class="n">x</span> <span class="p">(</span><span class="s">&#39;anim&#39;</span>  <span class="s">&#39;an&#39;</span><span class="p">)</span>    <span class="cm">/* signal f, since &#39;an&#39; and &#39;ad&#39; mis-match */</span>
</pre></div>


<DT><code>not C</code>
<DT><code>try C</code>
    <DD>These are like the integer tests, with the added feature that <B><I>c</I></B> is set
    back to its old position after an <B><I>f</I></B> signal is turned into <B><I>t</I></B>. So,

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="p">(</span><span class="ow">not</span> <span class="s">&#39;animation&#39;</span> <span class="ow">not</span> <span class="s">&#39;immersion&#39;</span><span class="p">)</span>
            <span class="cm">/* both tests are done at the start of the string */</span>

        <span class="o">$</span><span class="n">x</span> <span class="p">(</span><span class="ow">try</span> <span class="s">&#39;animus&#39;</span> <span class="ow">try</span> <span class="s">&#39;an&#39;</span>
            <span class="s">&#39;imad&#39;</span><span class="p">)</span>
            <span class="cm">/* - gives t */</span>
</pre></div>


<DL><DD><TABLE CELLPADDING=0>
<TR><TD>        &nbsp;<code>try C</code>&nbsp;     <TD></TD><TD> is equivalent to <TD></TD><TD>    &nbsp;<code>C or true</code>
</TABLE></DL>
<DT><code>test C</code>
    <DD>This does command &nbsp;<code>C</code>&nbsp; but without advancing <B><I>c</I></B>. Its signal is the same as
    the signal of &nbsp;<code>C</code>, but following signal <B><I>t</I></B>, <B><I>c</I></B> is set back to its old
    value.
<DL><DD><TABLE CELLPADDING=0>
<TR><TD>        &nbsp;<code>test C</code>&nbsp;       <TD></TD><TD>  is equivalent to   <TD></TD><TD>  &nbsp;<code>not not C</code>
<TR><TD>        &nbsp;<code>test C<SUB>1</SUB> C<SUB>2</SUB></code>&nbsp; <TD></TD><TD>  is equivalent to   <TD></TD><TD>  &nbsp;<code>C<SUB>1</SUB> and C<SUB>2</SUB></code>
</TABLE></DL>
<DT><code>fail C</code>
    <DD>This does &nbsp;<code>C</code>&nbsp; and gives signal <B><I>f</I></B>. It is equivalent to &nbsp;<code>C false</code>. Like
    &nbsp;<code>false</code>&nbsp; it is useful, but only rarely.

<DT><code>do C</code>
    <DD>This does &nbsp;<code>C</code>, puts <B><I>c</I></B> back to its old value and gives signal <B><I>t</I></B>. It is
    very useful as a way of suppressing the side effect of <B><I>f</I></B> signals and
    cursor movement.
<DL><DD><TABLE CELLPADDING=0>
<TR><TD>        &nbsp;<code>do C</code>&nbsp;     <TD></TD><TD>  is equivalent to   <TD></TD><TD>  &nbsp;<code>try test C</code>
<TR><TD>                     <TD></TD><TD>  or                 <TD></TD><TD>  &nbsp;<code>test try C</code>
</TABLE></DL>
<DT><code>goto C</code>
    <DD><B><I>c</I></B> is moved right until obeying &nbsp;<code>C</code>&nbsp; gives <B><I>t</I></B>. But if <B><I>c</I></B> cannot be moved
    right because it is at <B><I>l</I></B> the signal is <B><I>f</I></B>. <B><I>c</I></B> is set back to the position
    it had before the last obeying of &nbsp;<code>C</code>, so the effect is to leave <B><I>c</I></B> before
    the pattern which matched against &nbsp;<code>C</code>.

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="ow">goto</span> <span class="s">&#39;ad&#39;</span>         <span class="cm">/* positions c after &#39;anim&#39; */</span>
        <span class="o">$</span><span class="n">x</span> <span class="ow">goto</span> <span class="s">&#39;ax&#39;</span>         <span class="cm">/* signal f */</span>
</pre></div>


<DT><code>gopast C</code>
    <DD>Like goto, but <B><I>c</I></B> is not set back, so the effect is to leave <B><I>c</I></B> after
    the pattern which matched against &nbsp;<code>C</code>.

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="ow">gopast</span> <span class="s">&#39;ad&#39;</span>       <span class="cm">/* positions c after &#39;animad&#39; */</span>
</pre></div>


<DT><code>repeat C</code>
    <DD><code>C</code>&nbsp; is repeated until it gives <B><I>f</I></B>. When this happens <B><I>c</I></B> is set back to the
    position it had before the last repetition of &nbsp;<code>C</code>, and &nbsp;<code>repeat C</code>&nbsp; gives
    signal <B><I>t</I></B>. For example,

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="ow">repeat</span> <span class="ow">gopast</span> <span class="s">&#39;a&#39;</span> <span class="cm">/* position c after the last &#39;a&#39; */</span>
</pre></div>


<DT><code>loop AE C</code>
    <DD>This is like &nbsp;<code>C C ... C</code>&nbsp; written out AE times, where AE is an arithmetic
    expression. For example,

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="ow">loop</span> <span class="m">2</span> <span class="ow">gopast</span> <span class="p">(</span><span class="s">&#39;a&#39;</span> <span class="ow">or</span> <span class="s">&#39;e&#39;</span> <span class="ow">or</span> <span class="s">&#39;i&#39;</span> <span class="ow">or</span> <span class="s">&#39;o&#39;</span> <span class="ow">or</span> <span class="s">&#39;u&#39;</span><span class="p">)</span>
            <span class="cm">/* position c after the second vowel */</span>
</pre></div>


    The equivalent expression in C has the shape,

<div class="highlight"><pre>        <span class="p">{</span>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
             <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">AE</span><span class="p">;</span>
             <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">C</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>

<DT><code>atleast AE C</code>
    <DD>This is equivalent to &nbsp;<code>loop AE C repeat C</code>.

<DT><code>hop AE</code>
    <DD>moves <B><I>c</I></B> AE character positions towards <B><I>l</I></B>, but if AE is negative, or if
    there are less than AE characters between <B><I>c</I></B> and <B><I>l</I></B> the signal is <B><I>f</I></B>.
    For example,

<div class="highlight"><pre>        <span class="ow">test</span> <span class="ow">hop</span> <span class="m">3</span>
</pre></div>


    tests that <B><I>c:l</I></B> contains more than 2 characters.

<DT><code>next</code>
    <DD>is equivalent to &nbsp;<code>hop 1</code>.
</DL>

&nbsp;<H4>c) Moving text about</H4>


We have seen in (a) that &nbsp;<code>$x = y</code>, when &nbsp;<code>x</code>&nbsp; and &nbsp;<code>y</code>&nbsp; are strings, sets <B><I>c:l</I></B> of &nbsp;<code>x</code>
to the value of &nbsp;<code>y</code>. Conversely

<div class="highlight"><pre>        <span class="o">$</span><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">y</span>
</pre></div>


sets the value of &nbsp;<code>y</code>&nbsp; to the <B><I>c:l</I></B> region of &nbsp;<code>x</code>.
<BR><BR>
A more delicate mechanism for pushing text around is to define a substring,
or <I>slice</I> of the string being tested. Then

<DL>
<DT><code>[</code>
    <DD>sets the left-end of the slice to <B><I>c</I></B>,
<DT><code>]</code>
    <DD>sets the right-end of the slice to <B><I>c</I></B>,

<DT><span class="highlight"><code><span class="o">-&gt;</span> <span class="n">s</span>
</code></span>

    <DD>moves the slice to variable &nbsp;<code>s</code>,
<DT><span class="highlight"><code><span class="o">&lt;-</span> <span class="n">S</span>
</code></span>

    <DD>replaces the slice with variable (or literal) &nbsp;<code>S</code>.
</DL>
For example

<div class="highlight"><pre>        <span class="cm">/* assume x holds &#39;animadversion&#39; */</span>
        <span class="o">$</span><span class="n">x</span> <span class="p">(</span> <span class="p">[</span>          <span class="c1">// &#39;[animadversion&#39; - [ set as indicated</span>
             <span class="ow">loop</span> <span class="m">2</span> <span class="ow">gopast</span> <span class="s">&#39;a&#39;</span>
                       <span class="c1">// &#39;[anima|dversion&#39; - c is marked by &#39;|&#39;</span>
             <span class="p">]</span>         <span class="c1">// &#39;[anima]dversion&#39; - ] set as indicated</span>
             <span class="o">-&gt;</span> <span class="n">y</span>      <span class="c1">// y is &#39;anima&#39;</span>
           <span class="p">)</span>
</pre></div>


For any string, the slice ends should be assumed to be unset until they are
set with the two commands &nbsp;<code>[</code>, &nbsp;<code>]</code>. Thereafter the slice ends will retain
the same values until altered.

<DL>
<DT><span class="highlight"><code><span class="ow">delete</span>
</code></span>

    <DD>is equivalent to <span class="highlight"><code><span class="o">&lt;-</span> <span class="s">&#39;&#39;</span>
</code></span>

</DL>

This next example deletes all vowels in x,

<div class="highlight"><pre>        <span class="kd">define</span> <span class="n">vowel</span> <span class="p">(</span><span class="s">&#39;a&#39;</span> <span class="ow">or</span> <span class="s">&#39;e&#39;</span> <span class="ow">or</span> <span class="s">&#39;i&#39;</span> <span class="ow">or</span> <span class="s">&#39;o&#39;</span> <span class="ow">or</span> <span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="cm">/* ... */</span>
        <span class="o">$</span> <span class="n">x</span> <span class="ow">repeat</span> <span class="p">(</span> <span class="ow">gopast</span><span class="p">([</span><span class="n">vowel</span><span class="p">])</span> <span class="ow">delete</span> <span class="p">)</span>
</pre></div>


As this example shows, the slice markers &nbsp;<code>[</code>&nbsp; and &nbsp;<code>]</code>&nbsp; often appear as
pairs in a bracketed style, which makes for easy reading of the Snowball
scripts. But it must be remembered that, unusually in a computer
programming language, they are not true brackets.
<BR><BR>
More simply, text can be inserted at <B><I>c</I></B>.
<DL>
<DT><span class="highlight"><code><span class="ow">insert</span> <span class="n">S</span>
</code></span>

    <DD>insert variable or literal &nbsp;<code>S</code>&nbsp; before <B><I>c</I></B>, moving <B><I>c</I></B> to the right of the
    insert. &nbsp;<code>&lt;+</code>&nbsp; is a synonym for &nbsp;<code>insert</code>.

<DT><span class="highlight"><code><span class="ow">attach</span> <span class="n">S</span>
</code></span>

    <DD>the same, but leave <B><I>c</I></B> at the left of the insert.
</DL>

&nbsp;<H4>d) Marks</H4>


The cursor, <B><I>c</I></B>, (and the limit, <B><I>l</I></B>) can be thought of as having a numeric
value, from zero upwards:
<BR><PRE>
         | a | n | i | m | a | d | v | e | r | s | i | o | n |
         0   1   2   3   4   5   6   7   8   9  10  11  12  13
</PRE>
It is these numeric values of <B><I>c</I></B> and <B><I>l</I></B> which are accessible through
<code>cursor</code>&nbsp; and &nbsp;<code>limit</code>&nbsp; in arithmetic expressions.
<DL>
<DT><span class="highlight"><code><span class="ow">setmark</span> <span class="n">X</span>
</code></span>

    <DD>sets &nbsp;<code>X</code>&nbsp; to the current value of <B><I>c</I></B>, where &nbsp;<code>X</code>&nbsp; is an integer variable.

<DT><span class="highlight"><code><span class="ow">tomark</span> <span class="n">AE</span>
</code></span>

    <DD>moves <B><I>c</I></B> forward to the position given by AE,

<DT><span class="highlight"><code><span class="ow">atmark</span> <span class="n">AE</span>
</code></span>

    <DD>tests if <B><I>c</I></B> is at position AE (<B><I>t</I></B> or <B><I>f</I></B> signal).
</DL>
In the case of <span class="highlight"><code><span class="ow">tomark</span> <span class="n">AE</span>
</code></span>

, a similar fail condition occurs as with <span class="highlight"><code><span class="ow">hop</span> <span class="n">AE</span>
</code></span>

.
If <B><I>c</I></B> is already beyond AE, or if position <B><I>l</I></B> is before position AE, the
signal is <B><I>f</I></B>.
<BR><BR>
In the stemming algorithms, certain regions of the word are defined by
setting marks, and later the failure condition of <span class="highlight"><code><span class="ow">tomark</span>
</code></span>

 is used to see if
<B><I>c</I></B> is inside a particular region.
<BR><BR>
Two other commands put <B><I>c</I></B> at <B><I>l</I></B>, and test if <B><I>c</I></B> is at <B><I>l</I></B>,
<DL>
<DT><span class="highlight"><code><span class="ow">tolimit</span>
</code></span>

    <DD>moves <B><I>c</I></B> forward to <B><I>l</I></B> (signal <B><I>t</I></B> always),

<DT><span class="highlight"><code><span class="ow">atlimit</span>
</code></span>

    <DD>tests if <B><I>c</I></B> is at <B><I>l</I></B> (<B><I>t</I></B> or <B><I>f</I></B> signal).
</DL>

&nbsp;<H4>e) Changing <B><I>l</I></B></H4>


In this account of string commands we see <B><I>c</I></B> moving right towards <B><I>l</I></B>, while
<B><I>l</I></B> stays fixed at the end. In fact <B><I>l</I></B> can be reset to a new position between
<B><I>c</I></B> and its old position, to act as a shorter barrier for the movement of <B><I>c</I></B>.

<DL>
<DT><code>setlimit C<SUB>1</SUB> for C<SUB>2</SUB></code>
    <DD><code>C<SUB>1</SUB></code>&nbsp; is obeyed, and if it gives <B><I>f</I></B> the signal from &nbsp;<code>setlimit</code>
     is <B><I>f</I></B> with no further action.
<BR><BR>
    Otherwise, the final value of <B><I>c</I></B> becomes the new
    position of <B><I>l</I></B>. <B><I>c</I></B> is then set back to its old value before &nbsp;<code>C<SUB>1</SUB></code>&nbsp; was
    obeyed, and &nbsp;<code>C<SUB>2</SUB></code>&nbsp; is obeyed. Finally <B><I>l</I></B> is set back to its old position,
    and the signal of &nbsp;<code>C<SUB>2</SUB></code>&nbsp; becomes the signal of &nbsp;<code>setlimit</code>.
<BR><BR>
    So the signal is <B><I>f</I></B> if either &nbsp;<code>C<SUB>1</SUB></code>&nbsp; or &nbsp;<code>C<SUB>2</SUB></code>&nbsp; gives <B><I>f</I></B>, otherwise <B><I>t</I></B>.
    For example,

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="p">(</span> <span class="ow">setlimit</span> <span class="ow">goto</span> <span class="s">&#39;s&#39;</span>  <span class="c1">// &#39;animadver}sion&#39; new l as marked &#39;}&#39;</span>
         <span class="k">for</span>                <span class="c1">// below, &#39;|&#39; marks c after each goto</span>
         <span class="p">(</span> <span class="ow">goto</span> <span class="s">&#39;a&#39;</span> <span class="ow">and</span>     <span class="c1">// &#39;|animadver}sion&#39;</span>
           <span class="ow">goto</span> <span class="s">&#39;e&#39;</span> <span class="ow">and</span>     <span class="c1">// &#39;animadv|er}sion&#39;</span>
           <span class="ow">goto</span> <span class="s">&#39;i&#39;</span> <span class="ow">and</span>     <span class="c1">// &#39;an|imadver}sion&#39;</span>
         <span class="p">)</span>
       <span class="p">)</span>
</pre></div>


    This checks that x has characters &#8216;a&#8217;, &#8216;e&#8217; and &#8216;i&#8217; before the first
    &#8216;s&#8217;.
</DL>

&nbsp;<H4>f) Backward processing</H4>

String commands have been described with <B><I>c</I></B> to the left of <B><I>l</I></B> and moving
right. But the process can be reversed.

<DL>
<DT><span class="highlight"><code><span class="ow">backwards</span> <span class="n">C</span>
</code></span>

    <DD><B><I>c</I></B> and <B><I>l</I></B> are swapped over, and <B><I>c</I></B> moves left towards <B><I>l</I></B>. &nbsp;<code>C</code>&nbsp; is obeyed, the
    signal given by &nbsp;<code>C</code>&nbsp; becomes the signal of &nbsp;<code>backwards C</code>, and <B><I>c</I></B> and <B><I>l</I></B> are
    swapped back to their old values (except that <B><I>l</I></B> may have been adjusted
    because of deletions and insertions). &nbsp;<code>C</code>&nbsp; cannot contain another
    <span class="highlight"><code><span class="ow">backwards</span>
</code></span>

 command.

<DT><span class="highlight"><code><span class="ow">reverse</span> <span class="n">C</span>
</code></span>

    <DD>A similar idea, but here <B><I>c</I></B> simply moves left instead of moving right,
    with the beginning of the string as the limit, <B><I>l</I></B>. &nbsp;<code>C</code>&nbsp; can contain other
    <span class="highlight"><code><span class="ow">reverse</span>
</code></span>

 commands, but it cannot contain commands to do deletions or
    insertions &#x2014; it must be used for testing only. (Without this
    restriction Snowball's semantics would become very untidy.)
</DL>

Forward and backward processing are entirely symmetric, except that forward
processing is the default direction, and literal strings are always
written out forwards, even when they are being tested backwards. So the
following are equivalent,

<div class="highlight"><pre>    <span class="o">$</span><span class="n">x</span> <span class="p">(</span>
        <span class="s">&#39;ani&#39;</span> <span class="s">&#39;mad&#39;</span> <span class="s">&#39;version&#39;</span> <span class="ow">atlimit</span>
    <span class="p">)</span>

    <span class="o">$</span><span class="n">x</span> <span class="ow">backwards</span> <span class="p">(</span>
        <span class="s">&#39;version&#39;</span> <span class="s">&#39;mad&#39;</span> <span class="s">&#39;ani&#39;</span> <span class="ow">atlimit</span>
    <span class="p">)</span>
</pre></div>


If a routine is defined for backwards mode processing, it must be included
inside a &nbsp;<code>backwardmode(...)</code>&nbsp; declaration.

&nbsp;<H4>g) substring and among</H4>

The use of <span class="highlight"><code><span class="ow">substring</span>
</code></span>

 and <span class="highlight"><code><span class="k">among</span>
</code></span>

 is central to the implementation of the
stemming algorithms. It is like a case switch on strings. In its simpler
form,
<BR><PRE>
        substring among('S<SUB>1</SUB>' 'S<SUB>2</SUB>' 'S<SUB>3</SUB>' ...)
</PRE>
searches for the longest matching substring &nbsp;<code>'S<SUB>1</SUB>'</code>&nbsp; or &nbsp;<code>'S<SUB>2</SUB>'</code>&nbsp; or &nbsp;<code>'S<SUB>3</SUB>'</code>&nbsp; ... from
position <B><I>c</I></B>. (The &nbsp;<code>'S<SUB>i</SUB>'</code>&nbsp; must all be different.) So this has the same
semantics as
<BR><PRE>
        ('S<SUB>1</SUB>' or 'S<SUB>2</SUB>' or 'S<SUB>3</SUB>' ...)
</PRE>
&#x2014; so long as the &nbsp;<code>'S<SUB>i</SUB>'</code>&nbsp; are written out in decreasing order of length.
<BR><BR>
<code>substring</code>&nbsp; may be omitted, in which case it is attached to its following
<code>among</code>, so

<div class="highlight"><pre>    <span class="k">among</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span>
</pre></div>


without a preceding <span class="highlight"><code><span class="ow">substring</span>
</code></span>

 is equivalent to

<div class="highlight"><pre>    <span class="p">(</span><span class="ow">substring</span> <span class="k">among</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">))</span>
</pre></div>


<span class="highlight"><code><span class="ow">substring</span>
</code></span>

 may also be detached from its <span class="highlight"><code><span class="k">among</span>
</code></span>

, although it must
precede it textually in the same routine in which the <span class="highlight"><code><span class="k">among</span>
</code></span>

 appears.
The more general form of <span class="highlight"><code><span class="ow">substring</span> <span class="cm">/* ... */</span> <span class="k">among</span>
</code></span>

 is,
<BR><PRE>
    substring
    ...
    among( 'S<SUB>11</SUB>' 'S<SUB>12</SUB>' ... (C<SUB>1</SUB>)
           'S<SUB>21</SUB>' 'S<SUB>22</SUB>' ... (C<SUB>2</SUB>)
           ...

           'S<SUB>n1</SUB>' 'S<SUB>n2</SUB>' ... (C<SUB>n</SUB>)
         )
</PRE>
Obeying &nbsp;<code>substring</code>&nbsp; searches for a longest match among the &nbsp;<code>'S<SUB>ij</SUB>'</code>. The
signal from &nbsp;<code>substring</code>&nbsp; is <B><I>t</I></B> if a match is found, otherwise <B><I>f</I></B>. When the
<code>among</code>&nbsp; comes to be obeyed, the &nbsp;<code>C<SUB>i</SUB></code>&nbsp; corresponding to the matched &nbsp;<code>'S<SUB>ij</SUB>'</code>&nbsp; is
obeyed, and its signal becomes the signal of the &nbsp;<code>among</code>&nbsp; command.
<BR><BR>
<code>substring/among</code>&nbsp; pairs must match up textually inside each routine
definition. But there is no problem with an &nbsp;<code>among</code>&nbsp; containing other
<code>substring/among</code>&nbsp; pairs, and &nbsp;<code>substring</code>&nbsp; is optional before &nbsp;<code>among</code>&nbsp; anyway.
The essential constraint is that two &nbsp;<code>substring</code>s must be separated by an
<code>among</code>, and each &nbsp;<code>substring</code>&nbsp; must be followed by an &nbsp;<code>among</code>.
<BR><BR>
The effect of obeying &nbsp;<code>among</code>&nbsp; when the preceding &nbsp;<code>substring</code>&nbsp; is not obeyed
is undefined. This would happen for example here,

<div class="highlight"><pre>    <span class="ow">try</span><span class="p">(</span><span class="o">$</span><span class="n">x</span> <span class="o">!=</span> <span class="m">617</span> <span class="ow">substring</span><span class="p">)</span>
    <span class="k">among</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// &#39;substring&#39; is bypassed in the exceptional case where x == 617</span>
</pre></div>


The significance of separating the &nbsp;<code>substring</code>&nbsp; from the &nbsp;<code>among</code>&nbsp; is to allow
them to work in different contexts. For example,
<BR><PRE>
    setlimit tomark L for substring

    among( 'S<SUB>11</SUB>' 'S<SUB>12</SUB>' ... (C<SUB>1</SUB>)
           ...

           'S<SUB>n1</SUB>' 'S<SUB>n2</SUB>' ... (C<SUB>n</SUB>)
         )
</PRE>
Here the test for the longest &nbsp;<code>'S<SUB>ij</SUB>'</code>&nbsp; is constrained to the region between <B><I>c</I></B>
and the mark point given by integer &nbsp;<code>L</code>. But the commands &nbsp;<code>C<SUB>i</SUB></code>&nbsp; operate outside
this limit. Another example is
<BR><PRE>
    reverse substring

    among( 'S<SUB>11</SUB>' 'S<SUB>12</SUB>' ... (C<SUB>1</SUB>)
           ...

           'S<SUB>n1</SUB>' 'S<SUB>n2</SUB>' ... (C<SUB>n</SUB>)
         )
</PRE>
The substring test is in the opposite direction in the string to the
direction of the commands &nbsp;<code>C<SUB>i</SUB></code>.
<BR><BR>
The last &nbsp;<code>(C<SUB>n</SUB>)</code>&nbsp; may be omitted, in which case &nbsp;<code>(true)</code>&nbsp; is assumed.
<BR><BR>
Another possible abbreviation is that when &nbsp;<code>substring</code>&nbsp; is omitted, a
construct such as
<BR><PRE>
    among( 'S<SUB>11</SUB>' 'S<SUB>12</SUB>' ... (C C<SUB>1</SUB>)
           'S<SUB>21</SUB>' 'S<SUB>22</SUB>' ... (C C<SUB>2</SUB>)
           ...
           'S<SUB>n1</SUB>' 'S<SUB>n2</SUB>' ... (C C<SUB>n</SUB>)
         )
</PRE>
can be written
<BR><PRE>
    among( (C)
           'S<SUB>11</SUB>' 'S<SUB>12</SUB>' ... (C<SUB>1</SUB>)
           'S<SUB>21</SUB>' 'S<SUB>22</SUB>' ... (C<SUB>2</SUB>)
           ...
           'S<SUB>n1</SUB>' 'S<SUB>n2</SUB>' ... (C<SUB>n</SUB>)
         )
</PRE>
and this is just equivalent to
<BR><PRE>
    substring C
    among( 'S<SUB>11</SUB>' 'S<SUB>12</SUB>' ... (C<SUB>1</SUB>)
           'S<SUB>21</SUB>' 'S<SUB>22</SUB>' ... (C<SUB>2</SUB>)
           ...
           'S<SUB>n1</SUB>' 'S<SUB>n2</SUB>' ... (C<SUB>n</SUB>)
         )
</PRE>

In its most general form, each string &nbsp;<code>'S<SUB>ij</SUB>'</code>&nbsp; may be optionally followed by a
routine name,
<BR><PRE>
    among( (C)
           'S<SUB>11</SUB>' R<SUB>11</SUB> 'S<SUB>12</SUB>' R<SUB>12</SUB> ... (C<SUB>1</SUB>)
           'S<SUB>21</SUB>' R<SUB>21</SUB> 'S<SUB>22</SUB>' R<SUB>22</SUB> ... (C<SUB>2</SUB>)
           ...
           'S<SUB>n1</SUB>' R<SUB>n1</SUB> 'S<SUB>n2</SUB>' R<SUB>n1</SUB> ... (C<SUB>n</SUB>)
         )
</PRE>
So here each &nbsp;<code>R<SUB>ij</SUB></code>&nbsp; is either a routine name or is null. If null, it is equivalent
to a routine which simply returns signal <B><I>t</I></B>,

<div class="highlight"><pre>    <span class="kd">define</span> <span class="n">null</span> <span class="k">as</span> <span class="kc">true</span>
</pre></div>


&#x2014; so we can imagine each &nbsp;<code>'S<SUB>ij</SUB>'</code>&nbsp; having its associated routine
<code>R<SUB>ij</SUB></code>. Then obeying the &nbsp;<code>among</code>&nbsp; causes a search for the longest
<code>'S<SUB>ij</SUB>'</code>&nbsp; whose corresponding routine
<code>R<SUB>ij</SUB></code>&nbsp; gives <B><I>t</I></B>. The routines
<code>R<SUB>ij</SUB></code>&nbsp; should be written without any side-effects, other than the inevitable cursor
movement. (<B><I>c</I></B> is in any case set back to its old value following a call of
<code>R<SUB>ij</SUB></code>.)

<BR>&nbsp;<H2>8 Booleans</H2>

<span class="highlight"><code><span class="ow">set</span> <span class="n">B</span>
</code></span>

 and <span class="highlight"><code><span class="ow">unset</span> <span class="n">B</span>
</code></span>

 set &nbsp;<code>B</code>&nbsp; to true and false respectively, where &nbsp;<code>B</code>&nbsp; is a
boolean name. <span class="highlight"><code><span class="n">B</span>
</code></span>

 as a command gives a signal <B><I>t</I></B> if it is set true, <B><I>f</I></B>
otherwise. For example,

<div class="highlight"><pre>    <span class="kd">booleans</span> <span class="p">(</span> <span class="n">Y_found</span> <span class="p">)</span>   <span class="c1">// declare the boolean</span>

    <span class="cm">/* ... */</span>

    <span class="ow">unset</span> <span class="n">Y_found</span>          <span class="c1">// unset it</span>
    <span class="ow">do</span> <span class="p">(</span> <span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span> <span class="o">&lt;-</span><span class="s">&#39;Y&#39;</span> <span class="ow">set</span> <span class="n">Y_found</span> <span class="p">)</span>
       <span class="cm">/* if c:l begins &#39;y&#39; replace it by &#39;Y&#39; and set Y_found */</span>

    <span class="ow">do</span> <span class="ow">repeat</span><span class="p">(</span><span class="ow">goto</span> <span class="p">(</span><span class="n">v</span> <span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">])</span> <span class="o">&lt;-</span><span class="s">&#39;Y&#39;</span> <span class="ow">set</span> <span class="n">Y_found</span><span class="p">)</span>
       <span class="cm">/* repeatedly move down the string looking for v &#39;y&#39; and</span>
<span class="cm">          replacing &#39;y&#39; with &#39;Y&#39;. Whenever the replacement takes</span>
<span class="cm">          place set Y_found. v is a test for a vowel, defined as</span>
<span class="cm">          a grouping (see below). */</span>


    <span class="cm">/* Y_found means there are some letters Y in the string.</span>
<span class="cm">       Later we can use this to trigger a conversion back to</span>
<span class="cm">       lower case y. */</span>

    <span class="cm">/* ... */</span>

    <span class="ow">do</span> <span class="p">(</span><span class="n">Y_found</span> <span class="ow">repeat</span><span class="p">(</span><span class="ow">goto</span> <span class="p">([</span><span class="s">&#39;Y&#39;</span><span class="p">])</span> <span class="o">&lt;-</span> <span class="s">&#39;y&#39;</span><span class="p">)</span>
</pre></div>


<BR>&nbsp;<H2>9 Groupings</H2>

A grouping brings characters together and enables them to be looked for
with a single test.
<BR><BR>
If &nbsp;<code>G</code>&nbsp; is declared as a grouping, it can be defined by
<BR><PRE>
    define G G<SUB>1</SUB> <I>op</I> G<SUB>2</SUB> <I>op</I> G<SUB>3</SUB> ...
</PRE>
where <I>op</I> is &nbsp;<code>+</code>&nbsp; or &nbsp;<code>-</code>, and &nbsp;<code>G<SUB>1</SUB></code>, &nbsp;<code>G<SUB>2</SUB></code>, &nbsp;<code>G<SUB>3</SUB></code>&nbsp; are literal strings, or groupings that
have already been defined. (There can be zero or more of these additional
<I>op</I> components). For example,

<div class="highlight"><pre>    <span class="kd">define</span> <span class="n">capital_letter</span>  <span class="s">&#39;ABDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span>
    <span class="kd">define</span> <span class="n">small_letter</span>    <span class="s">&#39;abdefghijklmnopqrstuvwxyz&#39;</span>
    <span class="kd">define</span> <span class="n">letter</span>          <span class="n">capital_letter</span> <span class="o">+</span> <span class="n">small_letter</span>
    <span class="kd">define</span> <span class="n">vowel</span>           <span class="s">&#39;aeiou&#39;</span> <span class="o">+</span> <span class="s">&#39;AEIOU&#39;</span>
    <span class="kd">define</span> <span class="n">consonant</span>       <span class="n">letter</span> <span class="o">-</span> <span class="n">vowel</span>
    <span class="kd">define</span> <span class="n">digit</span>           <span class="s">&#39;0123456789&#39;</span>
    <span class="kd">define</span> <span class="n">alphanumeric</span>    <span class="n">letter</span> <span class="o">+</span> <span class="n">digit</span>
</pre></div>


Once &nbsp;<code>G</code>&nbsp; is defined, it can be used as a command, and is equivalent to a test
<BR><PRE>
    'ch1' or 'ch2' or ...
</PRE>
where &nbsp;<code>ch1</code>, &nbsp;<code>ch2</code>&nbsp; ... list all the characters in the grouping.
<BR><BR>
<span class="highlight"><code><span class="ow">non</span> <span class="n">G</span>
</code></span>

 is the converse test, and matches any character except the
characters of &nbsp;<code>G</code>. Note that <span class="highlight"><code><span class="ow">non</span> <span class="n">G</span>
</code></span>

 is not the same as <span class="highlight"><code><span class="ow">not</span> <span class="n">G</span>
</code></span>

, in fact
<BR><PRE>
    non G    is equivalent to     (not G next)
</PRE>
<span class="highlight"><code><span class="ow">non</span>
</code></span>

 may be optionally followed by hyphen, so one may write

<div class="highlight"><pre>    <span class="ow">non-</span><span class="n">vowel</span>
    <span class="ow">non-</span><span class="n">digit</span>
</pre></div>


etc.

<BR>&nbsp;<H2>10 A Snowball program</H2>


A complete program consists of a sequence of declarations followed by a
sequence of definitions of groupings and routines. Routines which are
implicitly defined as operating on <B><I>c:l</I></B> from right to left must be included
in a &nbsp;<code>backwardmode(...)</code>&nbsp; declaration.
<BR><BR>
A Snowball program is called up via a simple
<A HREF="../runtime/use.html">API</A>
through its defined
externals. For example,

<div class="highlight"><pre>    <span class="kd">externals</span> <span class="p">(</span> <span class="n">stem1</span> <span class="n">stem2</span> <span class="p">)</span>
    <span class="cm">/* ... */</span>
    <span class="kd">define</span> <span class="n">stem1</span> <span class="k">as</span> <span class="p">(</span> <span class="cm">/* stem1 commands */</span> <span class="p">)</span>
    <span class="kd">define</span> <span class="n">stem2</span> <span class="k">as</span> <span class="p">(</span> <span class="cm">/* stem2 commands */</span> <span class="p">)</span>
</pre></div>


The API also allows a current string to be defined, and this becomes the
<B><I>c:l</I></B> string for the external routine to work on. Its final value is the
result handed back through the API.
<BR><BR>
The strings, integers and booleans are accessible from any point in the
program, and exist throughout the running of the Snowball program. They are
therefore like static declarations in C.

<BR>&nbsp;<H2>11 Comments, and other whitespace fillers</H2>

At a deeper level, a program is a sequence of <I>tokens</I>, interspersed with
whitespace. Names, reserved words, literal numbers and strings are all
tokens. Various symbols, made up of non-alphanumerics, are also tokens.
<BR><BR>
A name, reserved word or number is terminated by the first character that
cannot form part of it. A symbol is recognised as the longest sequence of
characters that forms a valid symbol. So &nbsp;<code>+=-</code>&nbsp; is two symbols, &nbsp;<code>+=</code>&nbsp; and
<code>-</code>, because &nbsp;<code>+=</code>&nbsp; is a valid symbol in the language while &nbsp;<code>+=-</code>&nbsp; is not.
Whitespace separates tokens but is otherwise ignored. This of course is
like C.
<BR><BR>
Anywhere that whitespace can occur, there may also occur:
<BR><BR>
(a) Comments, in the usual multi-line &nbsp;<code>/* .... */</code>&nbsp; or single line
<code>// ...</code>&nbsp; format.
<BR><BR>
(b) Get directives. These are like &nbsp;<code>#include</code>&nbsp; commands in C, and have the form
<span class="highlight"><code><span class="kn">get</span> <span class="s">&#39;S&#39;</span>
</code></span>

, where &nbsp;<code>'S'</code>&nbsp; is a literal string. For example,

<div class="highlight"><pre>    <span class="kn">get</span> <span class="s">&#39;/home/martin/snowball/main-hdr&#39;</span> <span class="c1">// include the file contents</span>
</pre></div>


(c) <span class="highlight"><code><span class="n">stringescapes</span> <span class="n">XY</span>
</code></span>

 where &nbsp;<code>X</code>&nbsp; and &nbsp;<code>Y</code>&nbsp; are any two printing characters.
<BR><BR>
(d) <span class="highlight"><code><span class="kd">stringdef</span> <span class="n">m</span> <span class="s">&#39;S&#39;</span>
</code></span>

 where &nbsp;<code>m</code>&nbsp; is sequence of characters not including
whitespace and terminated with whitespace, and &nbsp;<code>'S'</code>&nbsp; is a literal string.

<BR>&nbsp;<H2>12 Character representation</H2>

In this description of Snowball, it is assumed that strings are composed of
<I>characters</I>, and that characters can be defined numerically, but the numeric range
of these characters is not defined. As implemented, three different schemes
are supported. Characters can either be (<I>a</I>) bytes in the range 0 to 255,
as in traditional C strings, or (<I>b</I>) byte pairs in the range 0 to 65535,
as in Java strings, or (<I>c</I>) UTF-8 encoded bytes sequences in the range 0
to 65535, so that a character may occupy 1, 2 or 3 bytes.

<BR><BR>

For case (<I>c</I>), we need to make a slight separation of the concept of
<I>characters</I> into <I>symbols</I>, the units of text being represented, and
<I>slots</I>, the units of space into which they map. (So in case (<I>a</I>), all
slots are one byte; in case (<I>b</I>) all slots are two bytes.)
<B><I>c</I></B> and <B><I>l</I></B> have numeric values that can be used in AEs (arithmetic
expressions). These values count the number of slots. Similarly
<code>setmark</code>, &nbsp;<code>tomark</code>&nbsp; and &nbsp;<code>atmark</code>&nbsp; are remembering and then using slot
counts. &nbsp;<code>size</code>&nbsp; and &nbsp;<code>sizeof</code>&nbsp; measure string size
in slots, not symbols. However, &nbsp;<code>hop N</code>&nbsp; moves <B><I>c</I></B> over &nbsp;<code>N</code>&nbsp; symbols,
not &nbsp;<code>N</code>&nbsp; slots, and &nbsp;<code>next</code>&nbsp; is equivalent to &nbsp;<code>hop 1</code>.

<BR><BR>

So long as these simple distinctions are recognised, the same Snowball
script can be compiled to work with any of the three encoding schemes.

<BR><BR>
<BR><BR>
</TR>

<TR><TD BGCOLOR="lightblue">
<BR>&nbsp;<H2>Snowball syntax</H2>

<DL><DD>
<code>||</code>&nbsp; is used for alternatives, &nbsp;<code>[<I>X</I>]</code>&nbsp; means that <I>X</I> is
optional, and &nbsp;<code>[<I>X</I>]*</code>&nbsp; means that <I>X</I> is repeated zero or more
times. meta-symbols are defined on the left. &nbsp;<code>&lt;char&gt;</code>&nbsp; means any
character.
<BR><BR>
The definition of &nbsp;<code>literal string</code>&nbsp; does not allow for the escaping
conventions established by the &nbsp;<code>stringescapes</code>&nbsp; directive. The command
<code>?</code>&nbsp; is a debugging aid.
<BR><BR>

<BR><PRE>
&lt;letter&gt;        ::= a || b || ... || z || A || B || ... || Z
&lt;digit&gt;         ::= 0 || 1 || ... || 9
&lt;name&gt;          ::= &lt;letter&gt; [ &lt;letter&gt; || &lt;digit&gt; || _ ]*
&lt;s_name&gt;        ::= &lt;name&gt;
&lt;i_name&gt;        ::= &lt;name&gt;
&lt;b_name&gt;        ::= &lt;name&gt;
&lt;r_name&gt;        ::= &lt;name&gt;
&lt;g_name&gt;        ::= &lt;name&gt;
&lt;literal string&gt;::= '[&lt;char&gt;]*'
&lt;number&gt;        ::= &lt;digit&gt; [ &lt;digit&gt; ]*

S               ::= &lt;s_name&gt; || &lt;literal string&gt;
G               ::= &lt;g_name&gt; || &lt;literal string&gt;

&lt;declaration&gt;   ::= strings ( [&lt;s_name&gt;]* ) ||
                    integers ( [&lt;i_name&gt;]* ) ||
                    booleans ( [&lt;b_name&gt;]* ) ||
                    routines ( [&lt;r_name&gt;]* ) ||
                    externals ( [&lt;r_name&gt;]* ) ||
                    groupings ( [&lt;g_name&gt;]* )

&lt;r_definition&gt;  ::= define &lt;r_name&gt; as C
&lt;plus_or_minus&gt; ::= + || -
&lt;g_definition&gt;  ::= define &lt;g_name&gt; G [ &lt;plus_or_minus&gt; G ]*

AE              ::= (AE) ||
                    AE + AE || AE - AE || AE * AE || AE / AE || - AE ||
                    maxint || minint || cursor || limit || size ||
                    sizeof &lt;s_name&gt; || &lt;i_name&gt; || &lt;number&gt;

&lt;i_command&gt;     ::= $ &lt;i_name&gt; = AE ||
                    $ &lt;i_name&gt; += AE || $ &lt;i_name&gt; -= AE ||
                    $ &lt;i_name&gt; *= AE || $ &lt;i_name&gt; /= AE ||
                    $ &lt;i_name&gt; == AE || $ &lt;i_name&gt; != AE ||
                    $ &lt;i_name&gt; &gt; AE || $ &lt;i_name&gt; &gt;= AE ||
                    $ &lt;i_name&gt; &lt; AE || $ &lt;i_name&gt; &lt;= AE ||

&lt;s_command&gt;     ::= $ &lt;s_name&gt; C

C               ::= ( [C]* ) ||
                    &lt;i_command&gt; || &lt;s_command&gt; || C or C || C and C ||
                    not C || test C || try C || do C || fail C ||
                    goto C || gopast C || repeat C || loop AE C ||
                    atleast AE C || S || = S || insert S || attach S ||
                    &lt;- S || delete ||  hop AE || next ||
                    =&gt; &lt;s_name&gt; || [ || ] || -&gt; &lt;s_name&gt; ||
                    setmark &lt;i_name&gt; || tomark AE || atmark AE ||
                    tolimit || atlimit || setlimit C for C ||
                    backwards C || reverse C || substring ||
                    among ( [&lt;literal string&gt; [&lt;r_name&gt;] || (C)]* ) ||
                    set &lt;b_name&gt; || unset &lt;b_name&gt; || &lt;b_name&gt; ||
                    &lt;r_name&gt; || &lt;g_name&gt; || non [-] &lt;g_name&gt; ||
                    true || false || ?

P              ::=  [P]* || &lt;declaration&gt; ||
                    &lt;r_definition&gt; || &lt;g_definition&gt; ||
                    backwardmode ( P )

&lt;program&gt;      ::=  P



synonyms:      &lt;+ for insert
</PRE>


</DL>

</TR>

</TABLE>
  </body>
</html>
